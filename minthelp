#!/bin/bash
########################################################################
#
#
#                       script: minthelp
#                           by: Dan Purgert    
#                      version: 0.2
#                         date: Sun Apr 24 16:00:04 EDT 2016
#                      purpose: Central menu / wrapper script for the
#                             : various option-* scripts used by the
#                             : linux mint community members to assist
#                             : new users with issues they are having.
#
#                      license: GPL v2 (only)
#                   repository: http://github.com/dpurgert
#              Two_Dogs source: http://github.com/two-dogs
#
#
########################################################################

if [ "$1" = "-h" ]; then
   printf "   minthelp
   -------------

   This script acts as a central wrapper / menu / updater for the other
   option-* scripts included in this package, rather than having each
   of them update the same files.  In the event an individual option
   script requires the use of sudo, it will make that known to the user
   at the time of execution.

   Options:
     Options for use when running stand-alone from the command line.
     If run from the menu, set these options with their menu options.
     -h    Print this help, and exit.

   USAGE:
     minthelp

   ROOT COMMANDS:
     If allowed, this script will update inxi and the PCI ID list.  In
     the event that the user does not want to update these two items,
     the child scripts can still be run, albeit with the possibility 
     that they will not provide as great of detail to the user or the
     people assisting with the problem.

   -------------"
   exit 0
fi

printf "Checking inxi and pci list.\nThis may take a few moments...\n"

#get inxi and the PCI List version numbers
inxiver="$(inxi --version | head -1 | cut -d\  -f2 | cut -d\- -f1)"
pciver="$(grep Version /usr/share/misc/pci.ids | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

#check for / get changelogs

if [ -f /tmp/inxi.log ] ; then
  printf "\ninxi changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
  fi
else
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
fi


if [ -f /tmp/pci.log ] ; then
  printf "\npci changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
  fi
else
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
fi

#get version info from changelogs
inxicur="$(grep Version /tmp/inxi.log | head -1 | cut -d\  -f2)"
pcicur="$(grep Version /tmp/pci.log | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

if [ "$inxicur" = "$inxiver" ] ; then 
  updinxi=false
  printf "\ninstalled inxi up to date.\n"
else
  updinxi=true
fi

if [ "$pcicur" = "$pciver" ] ; then 
  updpci=false
  printf "\ninstalled PCI List up to date.\n"
else
  updpci=true
fi


# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then
  if $updpci && $updinxi ; then
   printf "\nThis script requires root permissions to update inxi and\n"
   printf "the PCI ID list.\n"
   uprq=true
  elif $updpci ; then
   printf "\nThis script requires root permissions to update the PCI\n"
   printf "ID list.\n"
   uprq=true
  elif $updinxi ; then
   printf "\nThis script requires root permissions to update inxi\n"
   uprq=true
  else
   uprq=false
  fi
  
  if $uprq ; then 
    read -n 1 -p "Allow updates as root? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
       printf "\n\nNOT updating inxi or the PCI List.\n"
       printf "If you would like more information about this,\n"
       printf "run with the -h option.\n"
    else
       printf "\nUpdating, this will take a few moments...\n"
       if $updinxi ; then
         printf "\nUpdating inxi...\n"
         sudo inxi -U
       fi
      
       if $updpci ; then
         printf "\nUpdating PCI List...\n"
         sudo update-pciids
       fi
       printf "\nUpdates Complete!\n"
    fi
  fi
else
   printf "\n\n===================WARNING!!!====================\n"
   printf "Detected script being run as root user.  It is not\n"
   printf "advisable to do so, as any errors in this script,\n"
   printf "or in the commands that do not require elevated\n"
   printf "privileges can potentially harm your system.\n\n"
   printf "This script is designed to only elevate your user\n"
   printf "priveleges for the command(s) that require it, and\n"
   printf "then drop back to your standard user.\n\n"
   printf "Exiting.\n"
   exit 1
fi

printf "\n From here on out, all but three of the options do not require
 any elevated permissions.  The \"Drives\", \"Used Space\", and
 \"Sound\" options will ask your permission to run with elevated
 permissions. If not given, the program will skip over the part(s) that
 require elevated privileges.  

 PLEASE NOTE -- The \"Used Space\" option absolutely requires elevated
  permissions, and will not run without them.  This is due to your 
  \"normal\" user not having permission to check the usage of your HDD
  in system folders.\n\n"

#pause to allow user to read...

printf "\nWait to allow you to read.\n"
for i in {10..1}; do
  if [ $i -le 5 ]; then
    printf "$i...\n"
  fi
  sleep 1s
done

#finally made it to the menu!
clear
sel=1
hlp=0
vrb=0
mod=''
declare -a logs

while [ $sel -ne 0 ]
do
  select choice in "Drives" "Networking" "Packages" "Printing" \
   "Process Tree" "Sound" "System" "Used Drive Space" "Userspace"\
   "X org" "Set Help Mode" "Set Verbose Mode" "Upload Existing Log" \
   "Exit"
  do
    case $REPLY in
      1)
        bash ./option-drives $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      2)
        bash ./option-network $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      3)
        bash ./option-packages $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      4)
        bash ./option-print $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      5)
        bash ./option-pstree $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      6)
        bash ./option-sound $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      7)
        bash ./option-system $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      8)
        bash ./option-mountspace $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
      9)
        bash ./option-userspace $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
     10)
        bash ./option-xorg $mod
        printf "\nPausing to give you a chance to read.\n"
        sleep 3s
        break ;;
     11)
        if [ $vrb -eq 1 ]; then
          vrb=0
        fi
        if [ $hlp -eq 0 ] ; then
          printf "\nHelp Mode Enable\n"
          hlp=1
          mod="-h"
        else
          printf "\nHelp Mode Disable\n"
          hlp=0
          mod=''
        fi
        sleep 1s
        break ;;
     12)
        if [ $hlp -eq 1 ]; then
          hlp=0
        fi
        if [ $vrb -eq 0 ] ; then
          printf "\nVerbose Mode Enable\n"
          vrb=1
          mod="-v"
        else
          printf "\nVerbose Mode Disable\n"
          vrb=0
          mod=''
        fi
        sleep 1s
        break ;;
     13)
        sel=2
        logf=''
        define -a dest
        dpast=false
        gio=false
        pbin=false
        # check for what tools the user has installed
        # used later when we ask them where to send it
      
        if command -v curl 2>/dev/null ; then dpast=true ; fi
        if command -v gist 2>/dev/null ; then gio=true; fi
        if command -v pastebin 2>/dev/null ; then pbin=true; fi
       
        if $dpast ; then dest+="dpaste.com "; fi
        if $gio ; then dest+="gist.github.com ";fi
        if $pbin ; then dest+="pastebin.com " ;fi
        dest+="Exit"
    
        if [ -f ~/option-drives.log ] ; then logs+="Drives "; fi
        if [ -f ~/option-network.log ] ; then logs+="Network "; fi
        if [ -f ~/option-packages.log ] ; then logs+="Packages "; fi
        if [ -f ~/option-print.log ] ; then logs+="Printing ";fi
        if [ -f ~/option-pstree.log ] ; then logs+="Processes "; fi
        if [ -f ~/option-sound.log ] ; then logs+="Sound "; fi
        if [ -f ~/option-system.log ] ; then logs+="System "; fi
        if [ -f ~/option-mountspace.log ];then logs+="Space ";fi
        if [ -f ~/option-userspace.log ] ; then logs+="User "; fi
        if [ -f ~/option-xorg.log ] ; then logs+="Xorg "; fi
        logs+="Back"
        while [ $sel -eq  2 ] ; do
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have created.\n"
        printf "\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             printf "\noption-drives\n"
             logf="$HOME/option-drives.log"
             break ;;
           Network|network)
             printf "\noption-network\n"
             logf="$HOME/option-network.log"
             break ;;
           Packages|packages)
             printf "\noption-packages\n"
             logf="$HOME/option-packages.log"
             break ;;
           Printing|printing)
             printf "\noption-print\n"
             logf="$HOME/option-print.log"
             break ;;
           Processes|processes)
             printf "\noption-pstree\n"
             logf="$HOME/option-pstree.log"
             break ;;
           System|system)
             printf "\noption-system\n"
             logf="$HOME/option-system.log"
             break ;;
           Sound|sound)
             printf "\noption-sound\n"
             logf="$HOME/option-sound.log"
             break ;;
           Space|space)
             printf "\noption-mountspace\n"
             logf="$HOME/option-mountspace.log"
             break ;;
           User|user)
             printf "\noption-userspace\n"
             logf="$HOME/option-userspace.log"
             break ;;
           Xorg|xorg)
             printf "\noption-xorg\n"
             logf="$HOME/option-xorg.log"
             break ;;
           *)
             sel=1
             break ;;
          esac
        done
        if [ $sel -ne 1 ] ; then
        printf "Where should the file be sent?\n"
        printf "Use only the hostname to make your selection,\n"
        printf "for example \"pastebin\" to upload to pastebin.com.\n"
        select choice in ${dest[@]} 
        do
          case $REPLY in
            dpaste) 
             printf "\nSending to dpaste, this may take a moment." 
             printf "\n$(curl -s -F "expiry_days=1" -F "content=<$logf"\
              http://dpaste.com/api/v2/)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            gist)  
             printf "\nSending to gist, this may take a moment." 
             printf "\n$(gist-paste -ap < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            pastebin)
             printf "\nSending to pastebin, this may take a moment." 
             printf "\n$(pastebin < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            *)
             printf "\nNOT Sending anything.\n"
             sleep 1; break ;;
          esac
        done 
        fi
        done
        unset logs
        unset dest
        break ;;
      *)
        sel=0
        printf "\nExiting.\n"
        break ;;
    esac
  done
  clear
done
