#!/bin/bash
########################################################################
#
#
#                       script: minthelp
#                           by: Dan Purgert    
#                    copyright: 2016
#                      version: 0.5
#                         date: Wed May 18 16:50:25 EDT 2016
#                      purpose: Centralizec menu / interactive script
#                             : to perform various checks on a user's 
#                             : computer when they're trying to get help
#                             : from the Linux Mint community.
#                             : This is a consolidated version of
#                             : Two_Dogs' various option-* tools.
#
#                      license: GPL v2 (only)
#                   repository: http://github.com/dpurgert
#              Two_Dogs source: http://github.com/two-dogs
#
#
########################################################################

#This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#02110-1301, USA.

VERSION="0.5"
GPL="http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html#SEC3"

#kill the cursor
printf "\e[?25l"

#######################################################################
#                      FUNCTION LIBRARY
#
# Consolidated functions that handle all the various options that are
# available to a user.
########################################################################


########################################################################
#
#                            OPTION-DRIVES
#
########################################################################

drives() {
if [ "$1" = "-h" ]; then
   printf "\n   option-drives
   -------------

   This will gather information related to your HDD which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
     Print this help, and exit.
     Verbose Mode.  Print to stdout and logfile

   ROOT COMMANDS:
     Running this with the optional root commands enabled will allow the
     program to call \"parted\" which will provide you with the 
     partition information of the system's drives. It it not necessary
     to allow this, but it can be helpful if all else fails.
   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then
   printf "\nThis script requires root permissions to run parted\n"
   
   read -n 1 -p "Allow running command? [Y/n]" "chk"
   if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
      #exit, user answered no
      printf "\n\nNOT running parted, if you would like more \n"
      printf "information about what this does, run with\n"
      printf "the help option enabled.\n"
      update=false
   else
      update=true
   fi
fi

if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi


(
 printf "\n--EFI CHECK--\n" 
 [ -d /sys/firmware/efi ] &&
  printf "\nEFI boot on HDD\n" || printf "\nLegacy boot on HDD\n"
 printf "\n--EFI END--\n\n--INXI BEGIN--\n"
 inxi -c0 -MSRduplo 
 if $update ; then
   printf "\n--INXI END--\n\n--PARTITIONS BEGIN--\n" 
   sudo parted -l 
   printf "\n--PARTITIONS END--\n\n--LSBLK BEGIN--\n"
 else
   printf "\n--INXI END\n\n--LSBLK BEGIN--\n"
 fi 
 
 lsblk -fmi 

 printf "\n--LSBLK END--\n\n--FSTAB BEGIN--\n"
 cat /etc/fstab 
 printf "\n--FSTAB END--\n"
) | tee /tmp/option-drives.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-drives.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-MOUNTSPACE
#
########################################################################

mountsp() {
if [ "$1" = "-h" ]; then
   printf "\n   option-mountspace
   -------------

   This will gather system disc usage information, and provide the
   ten (10) largest directories (excluding /) in order to assist
   the person running it find potential folders that need to be 
   cleaned.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ROOT COMMANDS:
     This script requires elevated (root) privileges to run the \"du\"
     command in order to check system directories (e.g. /etc or /var),
     without allowing root to run \"du\", this script will not provide
     accurade disc usage information.

   ------------- "

   exit 0
fi

#create the spinner
spinner() {
  local pid=$1
  local del=0.5
  local sp='/-\|'
  local n=${#sp}
  printf ' '
  while [ $(ps a | awk '{print $1}' | grep $pid) ] ; do 
        printf '\b%s' "${sp:i++%n:1}"  
        sleep $del
  done
}

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then
   printf "\nThis option requires root permission to run the \"du\"\n"
   printf "command.\n"
   
   read -n 1 -p "Switch to root? [Y/n]" "chk"
   if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
      #exit, user answered no
      printf "\n\nNOT switching to root.  Exiting.\n"
      exit 0
   else 
      #run as sudo
      if [ "$1" != "-v" ]; then
      printf "\nQuiet Mode: Final notification until program completes."
      printf "\nDo not press any keys until prompted.\n"
      fi
      i=0
      $(sudo du -h / 2>/dev/null | grep '^[[:digit:]]*G' | \
       sort -hr | grep -v '/$' | head -10 | \
       tee /tmp/option-mountspace.log >&6 2>&1) & spinner $!
   fi
fi

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-mountspace.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-NETWORK
#
########################################################################

network() {
if [ "$1" = "-h" ]; then
   printf "\n   option-network
   -------------

   This script will gather network related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
     Print this help, and exit.
     Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

local upt=$(uptime | cut -d\  -f4-6 | cut -d, -f1,2)
local day=$(printf "$upt" | cut -d\  -f1)
local hr=$(printf "$upt" | cut -d\  -f3 | cut -d\: -f1)

if [ "$day" -gt 0 ] || [ "$hr" -gt 8 ]; then 
   printf "\n\n===========NOTE==============\n"
   printf "Computer has been running for: $upt.\n"
   printf "If your problem is recent, it may be fixed simply by\n"
   printf "rebooting the PC.  Also, if you control the router / modem\n"
   printf "reboot them too."
  
   read -n1 -p "Continue anyway? [Y/n]" "chk"
   if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then
      printf "\nExiting\n"
      exit 0
   else
      printf "\nContinuing without reboot.\n"
   fi
fi

if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi

(
 date 
 printf "\n--OPT NETWORK--\n\n--INXI START--\n"
 inxi -c0 -z -MSIpNnxx 
 printf "\n--INXI END--\n\n--DKMS STATUS START--\n"
 dkms status 
 printf "\n--DKMS STATUS END--\n\n--RFKILL START--\n"
 rfkill list 
 printf "\n--RFKILL END--\n\n--NMCLI START--\n"
 printf "\nNetworkManager\'s status:\n"
 nmcli -m tabular nm  
 printf "\n\nNetworkManager\'s connections:\n"  
 nmcli -m tabular c  
 printf "\n\nDevices managed by NetworkManager:\n"
 nmcli -m tabular d  
 printf "\n--NMCLI END--\n\n--MINTWIFI START--\n"
 printf "\nNOTE this prints things out of order, read carefully.\n\n"
 mintwifi 2>&1
 printf "\n--MINTWIFI END--\n\n--NDISWRAPPER LIST START--\n"
 ndiswrapper -l 
 printf "\n--NDISWRAPPER LIST END--\n\n--LSMOD START--\n"
 lsmod | grep -Ei 'blue|ath1|wifi|ndis|80211|hid' 
 printf "\n--LSMOD END--\n\n--HCICONFIG START--\n"
 hciconfig -a 
 printf "\n--HCICONFIG END--\n\n--SEARCH PS NM/BLUE START--\n"
 ps aux | grep -Ei 'blue|smb|nmbd|winbind|network|dnsmasq' 
 printf "\n--SEARCH PS NM/BLUE END--\n\n--DMESG START--\n"
 dmesg | grep -Ei \
  'error|fail|dkms|blue|wifi|net:|hid|tcp|udp|eth|wlan|ipv|80211|ath1|dns' 
 printf "\n--DMESG END--\n"
 date
) | tee /tmp/option-network.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-network.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-PACKAGES
#
########################################################################

packages() {
if [ "$1" = "-h" ]; then
   printf "\n   option-packages
   -------------

   This script will gather system related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

#create the spinner
spinner() {
  local pid=$1
  local del=0.5
  local sp='/-\|'
  local n=${#sp}
  printf ' '
  while [ $(ps a | awk '{print $1}' | grep $pid) ] ; do 
        printf '\b%s' "${sp:i++%n:1}"  
        sleep $del
  done
}

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi


if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi


( date 
  printf "\n--INXI START--\n"
  inxi -c0 -Sr 
  printf "\n--INXI END--\n\n--APT TERM.LOG CHECK BEGIN--\n"
  grep -Ei 'setting up|configur|remov|err|fail|log started|log ended' \
   /var/log/apt/term.log | tail --lines=60 ;
  printf "\n--APT TERM.LOG END--\n\n--APT UPDATE ERROR CHECK BEGIN--\n" 
  sudo apt update | grep -Ei 'fail|404' ;
  printf "\n--APT UPDATE ERROR CHECK END--\n"
  date 
) | tee /tmp/option-packages.log >&6 2>&1 & spinner $!

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-packages.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-PRINT
#
########################################################################

opprint() {
if [ "$1" = "-h" ]; then
   printf "\n   option-print
   -------------

   This script will gather printer related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

#create the spinner
spinner() {
  local pid=$1
  local del=0.5
  local sp='/-\|'
  local n=${#sp}
  printf ' '
  while [ $(ps a | awk '{print $1}' | grep $pid) ] ; do 
        printf '\b%s' "${sp:i++%n:1}"  
        sleep $del
  done
}

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi


if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi


( date 
 printf "\n--INXI BEGIN--\n"
 inxi -c0 -MS 
 printf "\n--INXI END--\n\n--CHECK CUPS DAEMONS--\n"
 [ -e /var/run/cups/cupsd.pid ] && \
  printf "\nCUPS Daemon (cupsd) Running\n" \
  || printf "\nCUPS Daemon (cupsd) Stopped\n"
 if [ -e /var/run/cups/cups-browsed.pid ]; then
   printf "\nCUPS Bonjour Daemon (cups-browsed) Running\n" 
 else
   printf "\nCUPS Bonjour Daemon (cups-browsed) Stopped\n"
   printf "=================NOTE=====================\n"
   printf "not all systems seem to create the pidfile\n"
   printf "   /var/run/cups/cups-browsed\n"
   printf "Appears that it is running as $(pgrep cups-browsed)\n"
   printf "==========================================\n"
 fi
 printf "\n--CHECK CUPS COMPLETE--\n\n--SCANNER TEST START--\n"
 scanimage -L 
 printf "\n--SCANNER TEST COMPLETE--\n\n--CUPS ERROR LOG START--\n"
 cat /var/log/cups/error_log 
 printf "\n--CUPS ERROR LOG END--\n\n--SYSLOG CUPS ERRORS START--\n"
 grep -Ei 'error|fail|cups|colord' /var/log/syslog 
 printf "\n--SYSLOG CUPS ERRORS END--\n"
 date 
) | tee /tmp/option-print.log >&6 2>&1 & spinner $!

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-print.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-PSTREE
#
########################################################################

pstree() {
if [ "$1" = "-h" ]; then
   printf "\n   option-pstree
   -------------

   This script will gather process related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi


if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi


(
  date 
  printf "\n--OPTION PSTREE--\n\n--CHECK HDD EFI INFO--\n"
  [ -d /sys/firmware/efi ] && printf "\nEFI boot on HDD\n" \
   || printf "\nLegacy boot on HDD]n" 
  printf "\n--EFI INFO END--\n\n--INXI START--\n"
  inxi -c0 -F 
  printf "\n--INXI END--\n\n--PSTREE START--\n"
  sudo pstree -ansup 
  printf "\n--PSTREE END--\n\n"
  date
) | tee /tmp/option-pstree.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-pstree.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-SOUND 
#
########################################################################

sound() {
if [ "$1" = "-h" ]; then
   printf "\n   option-sound
   -------------

   This script will gather sound related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ROOT COMMANDS:
     If allowed, this script will reload the sound drivers via alsa.  
     The script can be successfully run without reloading these, but 
     some issues may be resolved with a simple reload.

   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then
   printf "\nThis script requires root permissions to reload\n" 
   printf "the sound drivers with alsa.\n"
   
   read -n 1 -p "Execute these commands as root? [Y/n]" "chk"
   if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
      #exit, user answered no
      printf "\n\nNOT reloading system sound drivers.\n"
      printf "If you would like more information, run with \n"
      printf "the -h option.\n"
      update=false
   else
      printf "Re-loading sound drivers ... \n\n"
      sudo alsa force-reload >&6 2>&1
      printf "\nRoot commands complete."
      printf "\nProgram will continue running as user: $USER.\n\n"
      update=true
   fi
fi


if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi

( 
  date 
  printf "\n--OPTION SOUND/AUDIO--\n"
  if $update ; then
    printf "\n--ALSA RELOADED--\n"
  else
    printf "\n--ALSA NOT RELOADED--\n"
  fi
  printf "\n--INXI BEGIN--\n"
  inxi -c0 -MSGAxx 
  printf "\n--INXI END--\n\n--LSMOD BEGIN--\n"
  lsmod | grep -Ei 'snd|hda' 
  printf "\n--LSMOD END--\n\n--CHECK INSTALLED SOUND CARDS--\n"
  cat /proc/asound/cards 
  printf "\n--SOUND CARD CHECK END--\n\n--DMESG START--\n"
  dmesg | grep -Ei 'sound|snd|hda' 
  printf "\n--DMESG END--\n\n--CHECK RUNNING PROCESSES--\n"
  ps aux | grep -Ei 'pulse|rtkit' 
  printf "\n--PROCESS CHECK COMPLETE--\n\n"
  date 
) | tee /tmp/option-sound.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-sound.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-SYSTEM
#
########################################################################

systm() {
if [ "$1" = "-h" ]; then
   printf "   option-system
   -------------

   This script will gather system related information which may 
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi

(date
printf "\n--OPTION SYSTEM--\n\n--EFI CHECK START--\n"
[ -d /sys/firmware/efi ] && printf "\nEFI boot on HDD\n" \
 || printf "\nLegacy boot on HDD\n"
printf "\n--EFI CHECK END--\n\n--INXI START--\n"
inxi -c0 -Fzxxtcm5 
printf "\n--GRUB KERNEL OPTIONS START--\n"
grep -Ei 'GRUB_CMDLINE_' /etc/default/grub
printf "\n--GRUB KERNEL OPTIONS END--\n\n--X SESSION MANAGER START--\n"
update-alternatives --list x-session-manager
printf "\n--X SESSION MANAGER END--\n\n--DKMS STATUS START--\n"
dkms status
printf "\n--DKMS STATUS END--\n\n--SYSLOG START--\n"
grep -B1 -Ei 'fail|error|critical' /var/log/syslog
printf "\n--SYSLOG END--\n\n--VMWARE CHECK START--\n"
if grep -q vmmon /var/log/syslog ; then printf "\nfound vmware\n" ; fi 
printf "\n--VMWARE CHECK END--\n\n--DMESG START--\n"
dmesg | grep -B1 -Ei 'fail|error|critical'
printf "\n--DMESG END--\n"
date ) | tee /tmp/option-system.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-system.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-USERSPACE
#
########################################################################

usrspc() {
if [ "$1" = "-h" ]; then
   printf "   option-userspace
   -------------

   This script will gather system related information which may
   help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

exec 6>/dev/null
if [ "$1" = "-v" ]; then
   #verbose
   exec 6>&1
fi

if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi

(
  date 
  printf "\n--OPTION USERSPACE--\n\n--INXI START--\n"
  inxi -c0 -MSGrsxxtcm20 
  printf "\n--INXI END--\n\n--GRUB KERNEL OPTS START--\n"
  grep -Ei 'GRUB_CMDLINE_' /etc/default/grub 
  printf "\n--GRUB KERNEL OPTS END--\n"
  printf "\n--XSESSION ERRORS START--\n"
  grep -B1 -Ei 'error|fail' ~/.xsession-errors 
  printf "\n--XSESSION ERRORS END--\n"
  date 
  ) | tee /tmp/option-userspace.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-userspace.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            OPTION-XORG
#
########################################################################

xorg() {
if [ "$1" = "-h" ]; then
   printf "\n   option-xorg
   -------------

   This script will gather information about the X display system
   which may help the community troubleshoot the problem you are having.

   Options:
    These options can be set via the main menu.
      Print this help, and exit.
      Verbose Mode.  Print to stdout and logfile

   ------------- "

   exit 0
fi

exec 6>/dev/null 
if [ "$1" = "-v" ]; then
   #verbose   
   exec 6>&1
fi

if [ "$1" != "-v" ]; then
   printf "\nQuiet Mode: Final notification until program completes."
   printf "\nDo not press any keys until prompted.\n"
fi

 (
  date 
  printf "\n--OPTION XORG--\n\n--INXI START--\n"
  inxi -c0 -MSGIsprxx 
  printf "\n--INXI END--\n\n--BEGIN GRUB KERNEL OPTIONS--\n"
  grep -Ei 'GRUB_CMDLINE_' /etc/default/grub 
  printf "\n--END GRUB KERNEL OPTIONS--\n\n--XRANDR BEGIN--\n"
  xrandr 
  printf "\n--XRANDR END--\n\n--DKMS STATUS START--\n"
  dkms status 
  printf "\n--DKMS STATUS END--\n\n--LSMOD START--\n"
  lsmod | grep -Ei 'vid|nvi|int|i9|fgl|nouv|rad|vbox|ndi' \
  | grep -Eiv 'snd' 
  printf "\n--LSMOD END--\n\n--TERM.LOG START--\n"
  grep -Ei 'g up|config|dkms|module|install|remov|err|fail' \
  /var/log/apt/term.log | grep -Ei \
  'radeon|nvidia|nouveau|intel|fglrx|vbox|Log started|Log ended' 
  printf "\n--TERM.LOG END--\n\n--DPKG START--\n"
  dpkg -l | grep -Ei 'nvidia|fglrx' 
  printf "\n--DPKG END--\n\n--WEBINSTALL START--\n"
  [ -d /usr/share/ati/ ] &&  grep -i fglrx || \
  printf "\nNo ATI drivers.\n"
  printf "\n--WEBINSTALL END--\n\n--XORG.0.LOG START--\n"
  [ -e /var/log/Xorg.0.log ] && \
  grep -Ewi 'kernel|conf|WW|EE' /var/log/Xorg.0.log || \
  printf "\nXorg.0.log does not exist.\n"
  printf "\n--XORG.0.LOG END--\n\n--SYSLOG START--\n;"
  grep -Ei 'fail|error|critical' /var/log/syslog
  printf "\nS--SYSLOG END--\n"
  date 
  ) | tee /tmp/option-xorg.log >&6 2>&1

printf "\n\n============================\n"
printf "COMPLETED! A copy has been saved to:\n"
printf "   /tmp/option-xorg.log\n"
printf "============================\n\n"
}

########################################################################
#
#                            MAIN PROGRAM
#
########################################################################
if [ "$1" = "-h" ]; then
   printf "   minthelp
   -------------

   This script acts as a central wrapper / menu / updater for the other
   option-* scripts included in this package, rather than having each
   of them update the same files.  In the event an individual option
   script requires the use of sudo, it will make that known to the user
   at the time of execution.

   Options:
     Options for use when running stand-alone from the command line.
     If run from the menu, set these options with their menu options.
     -h    Print this help, and exit.

   USAGE:
     minthelp

   ROOT COMMANDS:
     If allowed, this script will update inxi and the PCI ID list.  In
     the event that the user does not want to update these two items,
     the child scripts can still be run, albeit with the possibility 
     that they will not provide as great of detail to the user or the
     people assisting with the problem.

   -------------"
   exit 0
   printf "\e[?25h" #show cursor
fi

clear

printf "\n\n\n\n
Mint helper version $VERSION, Copyright (C) 2016 Dan Purgert.
This program comes with ABSOLUTELY NO WARRANTY; for details see the GNU
GPL.  This is free software, and you are welcome to redistribute it
under certain conditions; see:\n$GPL\n for details.\n\n\n\n"

read -n1 -p "Press any key to continue"
clear
printf "\n\n\n\n
Checking inxi and pci list.\nThis may take a few moments...\n"

#get inxi and the PCI List version numbers
inxiver="$(inxi --version | head -1 | cut -d\  -f2 | cut -d\- -f1)"
pciver="$(grep Version /usr/share/misc/pci.ids | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

#set this so inxi updates can happen, then check if the system isn't
#getting in the way.
inxi=true
if [ -f /etc/inxi.conf ]; then
  tmp="$(grep B_ALLOW_UPDATE /etc/inxi.conf)"
  if [ "$tmp" = "B_ALLOW_UPDATE=false" ]; then 
    printf "\nCurrent inxi settings will prohibit you from updating.\n"
    printf "Updating will require root permissions.\n"
    read -n1 -p "Shall we correct this? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ $chk = "N" ]; then
      printf "\nOkay, DISABLING INXI UPDATES.\n"
      inxi=false
    else
      sudo sed -i.bak 's/B_ALLOW_UPDATE=false/B_ALLOW_UPDATE=true/'\
       /etc/inxi.conf
      printf "\ninxi config file updated.\n"
      printf "Original is /etc/inxi.conf.bak"
    fi
    unset tmp
  fi
fi

#check for / get changelogs

if [ -f /tmp/inxi.log ] ; then
  printf "\ninxi changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
  fi
else
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
fi


if [ -f /tmp/pci.log ] ; then
  printf "\npci changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
  fi
else
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
fi

#get version info from changelogs
inxicur="$(grep Version /tmp/inxi.log | head -1 | cut -d\  -f2)"
pcicur="$(grep Version /tmp/pci.log | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

if [ "$inxicur" = "$inxiver" ] ; then 
  updinxi=false
  printf "\ninstalled inxi up to date.\n"
else
  updinxi=true
fi

if [ "$pcicur" = "$pciver" ] ; then 
  updpci=false
  printf "\ninstalled PCI List up to date.\n"
else
  updpci=true
fi


# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then

  if command -v curl >/dev/null ; then 
    :
  else
    printf "\n\"curl\" does not seem to be installed.\n"
    printf "This program required to send to dpaste.\n"
    read -n 1 -p "Install curl? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
      printf "\nOkay, skipping curl install.\n"
    else
      sudo apt-get install curl
    fi
  fi
  if command -v gist 2>/dev/null ; then  i
    :
  else
    printf "\n\"gist\" does not seem to be installed.\n"
    printf "This program required to send to gist.github.com.\n"
    read -n 1 -p "Install gist? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
      printf "\nOkay, skipping gist install.\n"
    else
      sudo apt-get install gist 
    fi
  fi

  if $updpci && $updinxi ; then
   printf "\nThis script requires root permissions to update inxi and\n"
   printf "the PCI ID list.\n"
   uprq=true
  elif $updpci ; then
   printf "\nThis script requires root permissions to update the PCI\n"
   printf "ID list.\n"
   uprq=true
  elif $updinxi ; then
   printf "\nThis script requires root permissions to update inxi\n"
   uprq=true
  else
   uprq=false
  fi
  
  if $uprq ; then 
    read -n 1 -p "Allow updates as root? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
       printf "\n\nNOT updating inxi or the PCI List.\n"
       printf "If you would like more information about this,\n"
       printf "run with the -h option.\n"
    else
       printf "\nUpdating, this will take a few moments...\n"
       if $updinxi ; then
         printf "\nUpdating inxi...\n"
         sudo inxi -U
       fi
      
       if $updpci ; then
         printf "\nUpdating PCI List...\n"
         sudo update-pciids
       fi
       printf "\nUpdates Complete!\n"
    fi
  fi
else
   printf "\n\n===================WARNING!!!====================\n"
   printf "Detected script being run as root user.  It is not\n"
   printf "advisable to do so, as any errors in this script,\n"
   printf "or in the commands that do not require elevated\n"
   printf "privileges can potentially harm your system.\n\n"
   printf "This script is designed to only elevate your user\n"
   printf "priveleges for the command(s) that require it, and\n"
   printf "then drop back to your standard user.\n\n"
   printf "Exiting.\n"
   printf "\e[?25h" #show cursor
   exit 1
fi

clear
printf "\n\n\n\n\n\n"
printf "\n From here on out, all but three of the options do not require
 any elevated permissions.  The \"Drives\", \"Used Space\", and
 \"Sound\" options will ask your permission to run with elevated
 permissions. If not given, the program will skip over the part(s) that
 require elevated privileges.  

 PLEASE NOTE -- The \"Used Space\" option absolutely requires elevated
  permissions, and will not run without them.  This is due to your 
  \"normal\" user not having permission to check the usage of your HDD
  in system folders.\n\n"

#pause to allow user to read...

read -n1 -p "Press any key to continue."

#finally made it to the menu!
clear
sel=1
hlp=0
vrb=0
mod=''
declare -a logs

while [ $sel -ne 0 ]
do
  printf "Please make a selection:\n"
  select choice in "Drives" "Networking" "Packages" "Printing" \
   "Process Tree" "Sound" "System" "Used Drive Space" "Userspace"\
   "X org" "Set Help Mode" "Set Verbose Mode" "Upload Log" \
   "Delete Log" "View Log" "Exit"
  do
    case $REPLY in
      1)
        drives $mod
        read -n1 -p "Press any key to continue."
        break ;;
      2)
        network $mod
        read -n1 -p "Press any key to continue."
        break ;;
      3)
        packages $mod
        read -n1 -p "Press any key to continue."
        break ;;
      4)
        opprint $mod
        read -n1 -p "Press any key to continue."
        break ;;
      5)
        pstree $mod
        read -n1 -p "Press any key to continue."
        break ;;
      6)
        sound $mod
        read -n1 -p "Press any key to continue."
        break ;;
      7)
        systm $mod
        read -n1 -p "Press any key to continue."
        break ;;
      8)
        mountsp $mod
        read -n1 -p "Press any key to continue."
        break ;;
      9)
        usrspc $mod
        read -n1 -p "Press any key to continue."
        break ;;
     10)
        xorg $mod
        read -n1 -p "Press any key to continue."
        break ;;
     11)
        if [ $vrb -eq 1 ]; then
          vrb=0
        fi
        if [ $hlp -eq 0 ] ; then
          printf "\nHelp Mode Enable\n"
          hlp=1
          mod="-h"
        else
          printf "\nHelp Mode Disable\n"
          hlp=0
          mod=''
        fi
        sleep 1s
        break ;;
     12)
        if [ $hlp -eq 1 ]; then
          hlp=0
        fi
        if [ $vrb -eq 0 ] ; then
          printf "\nVerbose Mode Enable\n"
          vrb=1
          mod="-v"
        else
          printf "\nVerbose Mode Disable\n"
          vrb=0
          mod=''
        fi
        sleep 1s
        break ;;
     13)
        sel=2
        logf=''
        declare -a dest
        dpast=false
        gio=false
        pbin=false
        # check for what tools the user has installed
        # used later when we ask them where to send it
      
        if command -v curl 2>/dev/null ; then dpast=true ; fi
        if command -v gist 2>/dev/null ; then gio=true; fi
        if command -v pastebin 2>/dev/null ; then pbin=true; fi
       
        if $dpast ; then dest+=("dpaste.com"); fi
        if $gio ; then dest+=("gist.github.com");fi
        if $pbin ; then dest+=("pastebin.com") ;fi
        dest+=("Exit")
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        while [ $sel -eq  2 ] ; do
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have created.\n"
        printf "\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             logf="/tmp/option-drives.log"
             break ;;
           Network|network)
             logf="/tmp/option-network.log"
             break ;;
           Packages|packages)
             logf="/tmp/option-packages.log"
             break ;;
           Printing|printing)
             logf="/tmp/option-print.log"
             break ;;
           Processes|processes)
             logf="/tmp/option-pstree.log"
             break ;;
           System|system)
             logf="/tmp/option-system.log"
             break ;;
           Sound|sound)
             logf="/tmp/option-sound.log"
             break ;;
           Space|space)
             logf="/tmp/option-mountspace.log"
             break ;;
           User|user)
             logf="/tmp/option-userspace.log"
             break ;;
           Xorg|xorg)
             logf="/tmp/option-xorg.log"
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done
        if [ $sel -ne 1 ] && [ $sel -ne 2 ] ; then
        clear
        printf "Where should the file be sent?\n"
        printf "Use only the hostname to make your selection,\n"
        printf "for example \"pastebin\" to upload to pastebin.com.\n"
        select choice in ${dest[@]} 
        do
          case $REPLY in
            dpaste) 
             printf "\nSending to dpaste, this may take a moment." 
             printf "\n$(curl -s -F "expiry_days=1" -F "content=<$logf"\
              http://dpaste.com/api/v2/)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            gist)  
             printf "\nSending to gist, this may take a moment." 
             printf "\n$(gist-paste -ap < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            pastebin)
             printf "\nSending to pastebin, this may take a moment." 
             printf "\n$(pastebin < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            *)
             printf "\nNOT Sending anything.\n"
             sleep 1; break ;;
          esac
        done 
        fi
        done
        unset logs
        unset dest
        break ;;
     14)
        sel=2
        while [ $sel -eq  2 ] ; do
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have\n"
        printf "created or removed.\n\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             rm /tmp/option-drives.log
             break ;;
           Network|network)
             rm /tmp/option-network.log
             break ;;
           Packages|packages)
             rm /tmp/option-packages.log
             break ;;
           Printing|printing)
             rm /tmp/option-print.log
             break ;;
           Processes|processes)
             rm /tmp/option-pstree.log
             break ;;
           System|system)
             rm /tmp/option-system.log
             break ;;
           Sound|sound)
             rm /tmp/option-sound.log
             break ;;
           Space|space)
             rm /tmp/option-mountspace.log
             break ;;
           User|user)
             rm /tmp/option-userspace.log
             break ;;
           Xorg|xorg)
             rm /tmp/option-xorg.log
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done 
        unset logs
        done
        break ;;
     15)
        sel=2
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        while [ $sel -eq  2 ] ; do
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have\n"
        printf "created or removed.\n\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             less /tmp/option-drives.log
             break ;;
           Network|network)
             less /tmp/option-network.log
             break ;;
           Packages|packages)
             less /tmp/option-packages.log
             break ;;
           Printing|printing)
             less /tmp/option-print.log
             break ;;
           Processes|processes)
             less /tmp/option-pstree.log
             break ;;
           System|system)
             less /tmp/option-system.log
             break ;;
           Sound|sound)
             less /tmp/option-sound.log
             break ;;
           Space|space)
             less /tmp/option-mountspace.log
             break ;;
           User|user)
             less /tmp/option-userspace.log
             break ;;
           Xorg|xorg)
             less /tmp/option-xorg.log
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done 
        done
        unset logs
        break ;;
      *)
        sel=0
        printf "\nExiting.\n"
        sleep 1s
        break ;;
    esac
  done
  clear
done
printf "\e[?25h" #show cursor
