#!/bin/bash
########################################################################
#
#
#                       script: minthelp
#                           by: Dan Purgert    
#                    copyright: 2016
#                      version: 0.3
#                         date: Sun Apr 24 16:00:04 EDT 2016
#                      purpose: Central menu / wrapper script for the
#                             : various option-* scripts used by the
#                             : linux mint community members to assist
#                             : new users with issues they are having.
#
#                      license: GPL v2 (only)
#                   repository: http://github.com/dpurgert
#              Two_Dogs source: http://github.com/two-dogs
#
#
########################################################################

#This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#02110-1301, USA.

VERSION="0.3"
GPL="http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html#SEC3"

#kill the cursor
printf "\e[?25l"

if [ "$1" = "-h" ]; then
   printf "   minthelp
   -------------

   This script acts as a central wrapper / menu / updater for the other
   option-* scripts included in this package, rather than having each
   of them update the same files.  In the event an individual option
   script requires the use of sudo, it will make that known to the user
   at the time of execution.

   Options:
     Options for use when running stand-alone from the command line.
     If run from the menu, set these options with their menu options.
     -h    Print this help, and exit.

   USAGE:
     minthelp

   ROOT COMMANDS:
     If allowed, this script will update inxi and the PCI ID list.  In
     the event that the user does not want to update these two items,
     the child scripts can still be run, albeit with the possibility 
     that they will not provide as great of detail to the user or the
     people assisting with the problem.

   -------------"
   exit 0
   printf "\e[?25h" #show cursor
fi

clear

printf "\n\n\n\n
Mint helper version $VERSION, Copyright (C) 2016 Dan Purgert.
This program comes with ABSOLUTELY NO WARRANTY; for details see the GNU
GPL.  This is free software, and you are welcome to redistribute it
under certain conditions; see:\n$GPL\n for details.\n\n\n\n"

read -n1 -p "Press any key to continue"
clear
printf "\n\n\n\n
Checking inxi and pci list.\nThis may take a few moments...\n"

#get inxi and the PCI List version numbers
inxiver="$(inxi --version | head -1 | cut -d\  -f2 | cut -d\- -f1)"
pciver="$(grep Version /usr/share/misc/pci.ids | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

#set this so inxi updates can happen, then check if the system isn't
#getting in the way.
inxi=true
if [ -f /etc/inxi.conf ]; then
  tmp="$(grep B_ALLOW_UPDATE /etc/inxi.conf)"
  if [ "$tmp" = "B_ALLOW_UPDATE=false" ]; then 
    printf "\nCurrent inxi settings will prohibit you from updating.\n"
    printf "Updating will require root permissions.\n"
    read -n1 -p "Shall we correct this? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ $chk = "N" ]; then
      printf "\nOkay, DISABLING INXI UPDATES.\n"
      inxi=false
    else
      sudo sed -i.bak 's/B_ALLOW_UPDATE=false/B_ALLOW_UPDATE=true/'\
       /etc/inxi.conf
      printf "\ninxi config file updated.\n"
      printf "Original is /etc/inxi.conf.bak"
    fi
    unset tmp
  fi
fi

#check for / get changelogs

if [ -f /tmp/inxi.log ] ; then
  printf "\ninxi changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
  fi
else
    wget -O /tmp/inxi.log --quiet \
     https://raw.githubusercontent.com/smxi/inxi/master/inxi.changelog
fi


if [ -f /tmp/pci.log ] ; then
  printf "\npci changelog already exists.\n"
  read -n1 -p "Download a new copy? [y/N]" "chk"
  if [ "$chk" = "y" ] || [ "$chk" = "Y" ]; then
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
  fi
else
    wget -O /tmp/pci.log --quiet \
     https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids
fi

#get version info from changelogs
inxicur="$(grep Version /tmp/inxi.log | head -1 | cut -d\  -f2)"
pcicur="$(grep Version /tmp/pci.log | head -1 | tr -s ' ' \
  | cut -d\  -f2)"

if [ "$inxicur" = "$inxiver" ] ; then 
  updinxi=false
  printf "\ninstalled inxi up to date.\n"
else
  updinxi=true
fi

if [ "$pcicur" = "$pciver" ] ; then 
  updpci=false
  printf "\ninstalled PCI List up to date.\n"
else
  updpci=true
fi


# ask user if they want to execute root commands.
if [[ $EUID -ne 0 ]]; then
  if $updpci && $updinxi ; then
   printf "\nThis script requires root permissions to update inxi and\n"
   printf "the PCI ID list.\n"
   uprq=true
  elif $updpci ; then
   printf "\nThis script requires root permissions to update the PCI\n"
   printf "ID list.\n"
   uprq=true
  elif $updinxi ; then
   printf "\nThis script requires root permissions to update inxi\n"
   uprq=true
  else
   uprq=false
  fi
  
  if $uprq ; then 
    read -n 1 -p "Allow updates as root? [Y/n]" "chk"
    if [ "$chk" = "n" ] || [ "$chk" = "N" ]; then 
       printf "\n\nNOT updating inxi or the PCI List.\n"
       printf "If you would like more information about this,\n"
       printf "run with the -h option.\n"
    else
       printf "\nUpdating, this will take a few moments...\n"
       if $updinxi ; then
         printf "\nUpdating inxi...\n"
         sudo inxi -U
       fi
      
       if $updpci ; then
         printf "\nUpdating PCI List...\n"
         sudo update-pciids
       fi
       printf "\nUpdates Complete!\n"
    fi
  fi
else
   printf "\n\n===================WARNING!!!====================\n"
   printf "Detected script being run as root user.  It is not\n"
   printf "advisable to do so, as any errors in this script,\n"
   printf "or in the commands that do not require elevated\n"
   printf "privileges can potentially harm your system.\n\n"
   printf "This script is designed to only elevate your user\n"
   printf "priveleges for the command(s) that require it, and\n"
   printf "then drop back to your standard user.\n\n"
   printf "Exiting.\n"
   printf "\e[?25h" #show cursor
   exit 1
fi

printf "\n From here on out, all but three of the options do not require
 any elevated permissions.  The \"Drives\", \"Used Space\", and
 \"Sound\" options will ask your permission to run with elevated
 permissions. If not given, the program will skip over the part(s) that
 require elevated privileges.  

 PLEASE NOTE -- The \"Used Space\" option absolutely requires elevated
  permissions, and will not run without them.  This is due to your 
  \"normal\" user not having permission to check the usage of your HDD
  in system folders.\n\n"

#pause to allow user to read...

read -n1 -p "Press any key to continue."

#finally made it to the menu!
clear
sel=1
hlp=0
vrb=0
mod=''
declare -a logs

while [ $sel -ne 0 ]
do
  printf "Please make a selection:\n"
  select choice in "Drives" "Networking" "Packages" "Printing" \
   "Process Tree" "Sound" "System" "Used Drive Space" "Userspace"\
   "X org" "Set Help Mode" "Set Verbose Mode" "Upload Log" \
   "Delete Log" "View Log" "Exit"
  do
    case $REPLY in
      1)
        bash ./option-drives $mod
        read -n1 -p "Press any key to continue."
        break ;;
      2)
        bash ./option-network $mod
        read -n1 -p "Press any key to continue."
        break ;;
      3)
        bash ./option-packages $mod
        read -n1 -p "Press any key to continue."
        break ;;
      4)
        bash ./option-print $mod
        read -n1 -p "Press any key to continue."
        break ;;
      5)
        bash ./option-pstree $mod
        read -n1 -p "Press any key to continue."
        break ;;
      6)
        bash ./option-sound $mod
        read -n1 -p "Press any key to continue."
        break ;;
      7)
        bash ./option-system $mod
        read -n1 -p "Press any key to continue."
        break ;;
      8)
        bash ./option-mountspace $mod
        read -n1 -p "Press any key to continue."
        break ;;
      9)
        bash ./option-userspace $mod
        read -n1 -p "Press any key to continue."
        break ;;
     10)
        bash ./option-xorg $mod
        read -n1 -p "Press any key to continue."
        break ;;
     11)
        if [ $vrb -eq 1 ]; then
          vrb=0
        fi
        if [ $hlp -eq 0 ] ; then
          printf "\nHelp Mode Enable\n"
          hlp=1
          mod="-h"
        else
          printf "\nHelp Mode Disable\n"
          hlp=0
          mod=''
        fi
        sleep 1s
        break ;;
     12)
        if [ $hlp -eq 1 ]; then
          hlp=0
        fi
        if [ $vrb -eq 0 ] ; then
          printf "\nVerbose Mode Enable\n"
          vrb=1
          mod="-v"
        else
          printf "\nVerbose Mode Disable\n"
          vrb=0
          mod=''
        fi
        sleep 1s
        break ;;
     13)
        sel=2
        logf=''
        declare -a dest
        dpast=false
        gio=false
        pbin=false
        # check for what tools the user has installed
        # used later when we ask them where to send it
      
        if command -v curl 2>/dev/null ; then dpast=true ; fi
        if command -v gist 2>/dev/null ; then gio=true; fi
        if command -v pastebin 2>/dev/null ; then pbin=true; fi
       
        if $dpast ; then dest+=("dpaste.com"); fi
        if $gio ; then dest+=("gist.github.com");fi
        if $pbin ; then dest+=("pastebin.com") ;fi
        dest+=("Exit")
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        while [ $sel -eq  2 ] ; do
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have created.\n"
        printf "\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             logf="/tmp/option-drives.log"
             break ;;
           Network|network)
             logf="/tmp/option-network.log"
             break ;;
           Packages|packages)
             logf="/tmp/option-packages.log"
             break ;;
           Printing|printing)
             logf="/tmp/option-print.log"
             break ;;
           Processes|processes)
             logf="/tmp/option-pstree.log"
             break ;;
           System|system)
             logf="/tmp/option-system.log"
             break ;;
           Sound|sound)
             logf="/tmp/option-sound.log"
             break ;;
           Space|space)
             logf="/tmp/option-mountspace.log"
             break ;;
           User|user)
             logf="/tmp/option-userspace.log"
             break ;;
           Xorg|xorg)
             logf="/tmp/option-xorg.log"
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done
        if [ $sel -ne 1 ] && [ $sel -ne 2 ] ; then
        clear
        printf "Where should the file be sent?\n"
        printf "Use only the hostname to make your selection,\n"
        printf "for example \"pastebin\" to upload to pastebin.com.\n"
        select choice in ${dest[@]} 
        do
          case $REPLY in
            dpaste) 
             printf "\nSending to dpaste, this may take a moment." 
             printf "\n$(curl -s -F "expiry_days=1" -F "content=<$logf"\
              http://dpaste.com/api/v2/)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            gist)  
             printf "\nSending to gist, this may take a moment." 
             printf "\n$(gist-paste -ap < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            pastebin)
             printf "\nSending to pastebin, this may take a moment." 
             printf "\n$(pastebin < $logf)\n"
             read -n1 -p "Press any key to continue." "chk"
             break ;;
            *)
             printf "\nNOT Sending anything.\n"
             sleep 1; break ;;
          esac
        done 
        fi
        done
        unset logs
        unset dest
        break ;;
     14)
        sel=2
        while [ $sel -eq  2 ] ; do
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have\n"
        printf "created or removed.\n\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             printf "\noption-drives\n"
             rm /tmp/option-drives.log
             break ;;
           Network|network)
             printf "\noption-network\n"
             rm /tmp/option-network.log
             break ;;
           Packages|packages)
             printf "\noption-packages\n"
             rm /tmp/option-packages.log
             break ;;
           Printing|printing)
             printf "\noption-print\n"
             rm /tmp/option-print.log
             break ;;
           Processes|processes)
             printf "\noption-pstree\n"
             rm /tmp/option-pstree.log
             break ;;
           System|system)
             printf "\noption-system\n"
             rm /tmp/option-system.log
             break ;;
           Sound|sound)
             printf "\noption-sound\n"
             rm /tmp/option-sound.log
             break ;;
           Space|space)
             printf "\noption-mountspace\n"
             rm /tmp/option-mountspace.log
             break ;;
           User|user)
             printf "\noption-userspace\n"
             rm /tmp/option-userspace.log
             break ;;
           Xorg|xorg)
             printf "\noption-xorg\n"
             rm /tmp/option-xorg.log
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done 
        unset logs
        done
        break ;;
     15)
        sel=2
        if [ -f /tmp/option-drives.log ] ; then logs+=("Drives"); fi
        if [ -f /tmp/option-network.log ] ; then logs+=("Network"); fi
        if [ -f /tmp/option-packages.log ] ; then logs+=("Packages"); fi
        if [ -f /tmp/option-print.log ] ; then logs+=("Printing");fi
        if [ -f /tmp/option-pstree.log ] ; then logs+=("Processes"); fi
        if [ -f /tmp/option-sound.log ] ; then logs+=("Sound"); fi
        if [ -f /tmp/option-system.log ] ; then logs+=("System"); fi
        if [ -f /tmp/option-mountspace.log ];then logs+=("Space");fi
        if [ -f /tmp/option-userspace.log ] ; then logs+=("User"); fi
        if [ -f /tmp/option-xorg.log ] ; then logs+=("Xorg"); fi
        logs+=("Back")
        while [ $sel -eq  2 ] ; do
        clear
        printf "Select log using the NAME, not the NUMBER, as this\n"
        printf "menu changes, based on the logfiles you have\n"
        printf "created or removed.\n\n"
        select choice in ${logs[@]} 
        do
          case $REPLY in
           Drives|drives)
             printf "\noption-drives\n"
             less /tmp/option-drives.log
             break ;;
           Network|network)
             printf "\noption-network\n"
             less /tmp/option-network.log
             break ;;
           Packages|packages)
             printf "\noption-packages\n"
             less /tmp/option-packages.log
             break ;;
           Printing|printing)
             printf "\noption-print\n"
             less /tmp/option-print.log
             break ;;
           Processes|processes)
             printf "\noption-pstree\n"
             less /tmp/option-pstree.log
             break ;;
           System|system)
             printf "\noption-system\n"
             less /tmp/option-system.log
             break ;;
           Sound|sound)
             printf "\noption-sound\n"
             less /tmp/option-sound.log
             break ;;
           Space|space)
             printf "\noption-mountspace\n"
             less /tmp/option-mountspace.log
             break ;;
           User|user)
             printf "\noption-userspace\n"
             less /tmp/option-userspace.log
             break ;;
           Xorg|xorg)
             printf "\noption-xorg\n"
             less /tmp/option-xorg.log
             break ;;
           *)
             sel=1
             if [[ $REPLY =~ [0-9]{1,} ]] ; then 
               printf "Invalid choice selected."
               sel=2
               sleep 1s
               clear
             fi
             break ;;
          esac
        done 
        done
        unset logs
        break ;;
      *)
        sel=0
        printf "\nExiting.\n"
        sleep 1s
        break ;;
    esac
  done
  clear
done
printf "\e[?25h" #show cursor
